//@version=4
strategy("pg GRIND BTC [45MIN]", overlay=true,  pyramiding=1,initial_capital = 10000, default_qty_type= strategy.percent_of_equity, default_qty_value = 100, calc_on_order_fills=false, slippage=0,commission_type=strategy.commission.percent,commission_value=0.04)
//SOURCE =============================================================================================================================================================================================================================================================================================================
src = input(hl2)

// POSITION ==========================================================================================================================================================================================================================================================================================================

Position = input("Both", title= "Longs / Shorts", options = ["Both","Longs","Shorts"])

is_Long = Position == "SHORT" ? na : true
is_Short = Position == "LONG" ? na : true

// INPUTS ============================================================================================================================================================================================================================================================================================================

//ADX --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Act_ADX = input(true, title = "AVERAGE DIRECTIONAL INDEX", type = input.bool, group = "ADX")
ADX_options = input("MASANAKAMURA", title = "ADX OPTION", options = ["CLASSIC", "MASANAKAMURA"], group = "ADX")
ADX_len = input(9, title = "ADX LENGTH", type = input.integer, minval = 1, group = "ADX")
th = input(12, title = "ADX THRESHOLD", type = input.float, minval = 0, step = 0.5, group = "ADX")

//RSI----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

len_3 = input(100, title="RSI lenght", group = "Relative Strenght Indeks")
src_3 = input(open, title="RSI Source", group = "Relative Strenght Indeks")

//Volume weight------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

maLength = input(51, title="Volume Weight Length", type=input.integer, minval=1, group = "Volume")
maType = input(defval="SMA", title="Volume Weight Type", type=input.string,  options=["EMA", "SMA", "HMA", "WMA", "DEMA"], group = "Volume")
rvolTrigger = input(1.3, title="Volume To Trigger Signal", type=input.float, step=0.1, minval=0.1, group = "Volume")

//TREND STRENGHT--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

n1 = input(10, title= "Channel Length", group="Trend Strenght")
n2 = input(21, title= "Average Length", group="Trend Strenght")

//JMA--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

inp = input(defval=close, title="JMA Source", type=input.source, group = "Jurik Moving Average")
reso = input("", title="JMA Resolution", type=input.resolution, group = "Jurik Moving Average")
rep = input(false, title="JMA Allow Repainting?", type=input.bool, group = "Jurik Moving Average")
src0 = security(syminfo.tickerid, reso, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
lengths = input(50, title="JMA Length", type=input.integer, group = "Jurik Moving Average")

//MACD----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

fast_length = input(3, title="Fast Length", type=input.integer, group="MACD")
slow_length = input(4, title="Slow Length", type=input.integer, group="MACD")
signal_length = input(7, title="Signal Smoothing", type=input.integer, group="MACD")

//MA----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

length = input(55, title="MA Length", minval=1, group="Fast MA" )
matype = input(1, title="AvgType", minval=1, maxval=5, group="Fast MA")


//SAR-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

start = input(0.011, title="SAR Start", type=input.float, step=0.001, group = "Parabolic SAR")
increment = input(0.006, title="SAR Increment", type=input.float, step=0.001, group = "Parabolic SAR")
maximum = input(0.08, title="SAR Maximum", type=input.float, step=0.01, group = "Parabolic SAR")
width = input(1, title="SAR Point Width", type=input.integer, minval=1, group = "Parabolic SAR")

//Volume Delta ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

periodMa = input(5, title="Delta Length", group="Volume")

//BACKTESTING ====================================================================================================================================================================================================================================================================================================

ACT_BT = input(true, title="BACKTEST", type = input.bool, group= "BACKTEST")
long_ = input(true, title="Longs", group= "BACKTEST")
short_ = input(true, title="Shorts", group= "BACKTEST")
risk = input(100, group= "BACKTEST")

//SCALPING========================================================================================================================================================================================================================================================================================================


//Inputs----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ACT_SCLP = input(true, title = "SCALPING", type = input.bool, group="Scalping")
HiLoLen = input(24, title="Scalping Lenght", minval=2, group="Scalping")
fastEMAlength = input(10, title="Fast EMA lenght", minval=2, group="Scalping")
mediumEMAlength = input(100, title="Medium EMA lenght", minval=2, group="Scalping")
slowEMAlength = input(500, title="Slow EMA lenght", minval=2, group="Scalping")
filterBW = input(false, title="Filter")
Lookback = input(6, title="Pullback Lookback")
UseHAcandles = input(true, title="Use H.A Calculations")

//Indicator----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

haClose = UseHAcandles ? security(heikinashi(syminfo.tickerid), timeframe.period, close) : close
haOpen = UseHAcandles ? security(heikinashi(syminfo.tickerid), timeframe.period, open) : open
haHigh = UseHAcandles ? security(heikinashi(syminfo.tickerid), timeframe.period, high) : high
haLow = UseHAcandles ? security(heikinashi(syminfo.tickerid), timeframe.period, low) : low
isRegularFractal(mode) =>
    ret = mode == 1 ? high[4] < high[3] and high[3] < high[2] and high[2] > high[1] and 
       high[1] > high[0] : mode == -1 ? 
       low[4] > low[3] and low[3] > low[2] and low[2] < low[1] and low[1] < low[0] : 
       false
    ret
isBWFractal(mode) =>
    ret = mode == 1 ? high[4] < high[2] and high[3] <= high[2] and high[2] >= high[1] and 
       high[2] > high[0] : mode == -1 ? 
       low[4] > low[2] and low[3] >= low[2] and low[2] <= low[1] and low[2] < low[0] : 
       false
    ret
fastEMA = ema(haClose, fastEMAlength)
mediumEMA = ema(haClose, mediumEMAlength)
slowEMA = ema(haClose, slowEMAlength)
pacC = ema(haClose, HiLoLen)
pacL = ema(haLow, HiLoLen)
pacU = ema(haHigh, HiLoLen)
TrendDirection = fastEMA > mediumEMA and pacL > mediumEMA ? 1 : 
   fastEMA < mediumEMA and pacU < mediumEMA ? -1 : 0
filteredtopf = filterBW ? isRegularFractal(1) : isBWFractal(1)
filteredbotf = filterBW ? isRegularFractal(-1) : isBWFractal(-1)
valuewhen_H0 = valuewhen(filteredtopf == true, high[2], 0)
valuewhen_H1 = valuewhen(filteredtopf == true, high[2], 1)
valuewhen_H2 = valuewhen(filteredtopf == true, high[2], 2)
higherhigh = filteredtopf == false ? false : 
   valuewhen_H1 < valuewhen_H0 and valuewhen_H2 < valuewhen_H0
lowerhigh = filteredtopf == false ? false : 
   valuewhen_H1 > valuewhen_H0 and valuewhen_H2 > valuewhen_H0
valuewhen_L0 = valuewhen(filteredbotf == true, low[2], 0)
valuewhen_L1 = valuewhen(filteredbotf == true, low[2], 1)
valuewhen_L2 = valuewhen(filteredbotf == true, low[2], 2)
higherlow = filteredbotf == false ? false : 
   valuewhen_L1 < valuewhen_L0 and valuewhen_L2 < valuewhen_L0
lowerlow = filteredbotf == false ? false : 
   valuewhen_L1 > valuewhen_L0 and valuewhen_L2 > valuewhen_L0
TradeDirection = 0
TradeDirection := nz(TradeDirection[1])
pacExitU = haOpen < pacU and haClose > pacU and barssince(haClose<pacC)<=Lookback
pacExitL = haOpen > pacL and haClose < pacL and barssince(haClose>pacC)<=Lookback
Buy = TrendDirection == 1 and pacExitU
Sell = TrendDirection == -1 and pacExitL
TradeDirection := TradeDirection == 1 and haClose<pacC ? 0 : 
   TradeDirection == -1 and haClose>pacC ? 0 : 
   TradeDirection == 0 and Buy ? 1 : 
   TradeDirection == 0 and Sell ? -1 : TradeDirection
L_scalp = nz(TradeDirection[1]) == 0 and TradeDirection == 1
S_scalp = nz(TradeDirection[1]) == 0 and TradeDirection == -1





//INDICATORS ==============================================================================================================================================================================================================================================================



//ADX-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

calcADX(_len) =>
    up = change(high)
	down = -change(low)
	plusDM = na(up)   ? na : (up > down and up > 0   ? up   : 0)
    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)
	truerange = rma(tr, _len)
	_plus = fixnan(100 * rma(plusDM, _len)  / truerange)
	_minus = fixnan(100 * rma(minusDM, _len) / truerange)
	sum = _plus + _minus
	_adx = 100 * rma(abs(_plus - _minus) / (sum == 0 ? 1 : sum), _len)
    [_plus,_minus,_adx]
calcADX_Masanakamura(_len) =>
    SmoothedTrueRange = 0.0
    SmoothedDirectionalMovementPlus = 0.0
    SmoothedDirectionalMovementMinus = 0.0
    TrueRange = max(max(high - low, abs(high - nz(close[1]))), abs(low - nz(close[1])))
    DirectionalMovementPlus = high - nz(high[1]) > nz(low[1]) - low ? max(high - nz(high[1]), 0) : 0
    DirectionalMovementMinus = nz(low[1]) - low > high - nz(high[1]) ? max(nz(low[1]) - low, 0)   : 0
    SmoothedTrueRange := nz(SmoothedTrueRange[1]) - (nz(SmoothedTrueRange[1]) /_len) + TrueRange
    SmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1])  - (nz(SmoothedDirectionalMovementPlus[1])  / _len) + DirectionalMovementPlus
    SmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - (nz(SmoothedDirectionalMovementMinus[1]) / _len) + DirectionalMovementMinus
    DIP = SmoothedDirectionalMovementPlus  / SmoothedTrueRange * 100
    DIM = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100
    DX = abs(DIP-DIM) / (DIP+DIM)*100
    adx = sma(DX, _len)
    [DIP,DIM,adx]
[DIPlusC,DIMinusC,ADXC] = calcADX(ADX_len) 
[DIPlusM,DIMinusM,ADXM] = calcADX_Masanakamura(ADX_len)
DIPlus = ADX_options == "CLASSIC" ? DIPlusC    : DIPlusM
DIMinus = ADX_options == "CLASSIC" ? DIMinusC   : DIMinusM
ADX = ADX_options == "CLASSIC" ? ADXC       : ADXM
L_adx = DIPlus > DIMinus and ADX > th
S_adx = DIPlus < DIMinus and ADX > th

//RSI------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

up_3 = rma(max(change(src_3), 0), len_3)
down_3 = rma(-min(change(src_3), 0), len_3)
rsi_3 = down_3 == 0 ? 100 : up_3 == 0 ? 0 : 100 - (100 / (1 + up_3 / down_3))
L_rsi = (rsi_3 < 70)
S_rsi = (rsi_3 > 30) 

//TREND STRENGHT---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ap = hlc3 
esa = ema(ap, n1)
d = ema(abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d)
tci = ema(ci, n2)
wt1 = tci
wt2 = sma(wt1,4)
mfi_upper = sum(volume * (change(hlc3) <= 0 ? 0 : hlc3), 58)
mfi_lower = sum(volume * (change(hlc3) >= 0 ? 0 : hlc3), 58)
_mfi_rsi(mfi_upper, mfi_lower) =>
    if mfi_lower == 0
        100
    if mfi_upper == 0
        0
	100.0 - (100.0 / (1.0 + mfi_upper / mfi_lower))
mf = _mfi_rsi(mfi_upper, mfi_lower)
mfi = (mf - 50) * 3
L_mfi = mfi > 8
S_mfi = mfi < -8

//Volume weight------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

getMA0(length) =>
    maPrice = ema(volume, length)
    if maType == "SMA"
        maPrice := sma(volume, length)
    if maType == "HMA"
        maPrice := hma(volume, length)
    if maType == "WMA"
        maPrice := wma(volume, length)
    if maType == "DEMA"
        e1 = ema(volume, length)
        e2 = ema(e1, length)
        maPrice := 2 * e1 - e2
    maPrice

ma = getMA0(maLength)
rvol = volume / ma

volumegood = volume > rvolTrigger * ma

//JMA------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

jsa = (src0 + src0[lengths]) / 2
sig = src0 > jsa ? 1 : src0 < jsa ? -1 : 0
L_jma = sig > 0 
S_jma = sig < 0 

//MACD-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

fast_ma = ema(src, fast_length)
slow_ma = ema(src, slow_length)
macd = fast_ma - slow_ma
signal_ = sma(macd, signal_length)
L_macd = macd > signal_ 
S_macd = macd < signal_ 

//MA----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

simplema = sma(src,length)
exponentialma = ema(src,length)
hullma = wma(2*wma(src, length/2)-wma(src, length), round(sqrt(length)))
weightedma = wma(src, length)
volweightedma = vwma(src, length)
avgval = matype==1 ? simplema : matype==2 ? exponentialma : matype==3 ? hullma : matype==4 ? weightedma : matype==5 ? volweightedma : na
MA_speed = (avgval / avgval[1] -1 ) *100
L_s_ma = MA_speed > 0 
S_s_ma = MA_speed < 0 

//SAR-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

psar = sar(start, increment, maximum)
dir = psar < close ? 1 : -1
L_sar = dir ==1   
S_sar = dir ==-1  

//Volume Delta --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

bullPower = iff(close < open, iff(close[1] < open, max(high - close[1], close - low), max(high - open, close - low)), iff(close > open, iff(close[1] > open,  high - low, max(open - close[1], high - low)), iff(high - close > close - low, iff(close[1] < open, max(high - close[1], close - low), high - open), iff(high - close < close - low, iff(close[1] > open, high - low, max(open - close[1], high - low)), iff(close[1] > open, max(high - open, close - low), iff(close[1] < open, max(open - close[1], high - low), high-low))))))
bearPower = iff(close < open, iff(close[1] > open, max(close[1] - open, high - low), high - low), iff(close > open, iff(close[1] > open, max(close[1] - low, high - close), max(open - low, high - close)), iff(high - close > close - low, iff(close[1] > open, max(close[1] - open, high - low), high - low), iff(high - close < close - low, iff(close[1] > open, max(close[1] - low, high - close), open - low), iff(close[1] > open, max(close[1] - open, high - low), iff(close[1] < open, max(open - low, high - close), high - low))))))
bullVolume = (bullPower / (bullPower + bearPower)) * volume
bearVolume = (bearPower / (bullPower + bearPower)) * volume
delta = bullVolume - bearVolume
cvd = cum(delta)
cvdMa = sma(cvd, periodMa)
L_delta = cvd > cvdMa
S_delta = cvd < cvdMa

//CONDITIONS =======================================================================================================================================================================================================================================================================================================

L_scalp_condt = L_scalp and ACT_SCLP
S_scalp_condt = S_scalp and ACT_SCLP

//L/S variables----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

var bool longCond = na, var bool shortCond = na, longCond := nz(longCond[1]), shortCond := nz(shortCond[1])
var int CondIni_long = 0, var int CondIni_short = 0, CondIni_long := nz(CondIni_long[1]), CondIni_short := nz(CondIni_short[1])
var bool Final_longCondition = na, var bool Final_shortCondition = na, Final_longCondition := nz(Final_longCondition[1]), Final_shortCondition := nz(Final_shortCondition[1])
var bool BT_Final_longCondition = na, var bool BT_Final_shortCondition = na, BT_Final_longCondition := nz(BT_Final_longCondition[1]), BT_Final_shortCondition := nz(BT_Final_shortCondition[1])
var float last_open_longCondition = na, var float last_open_shortCondition = na
var int last_longCondition = na, var int last_shortCondition = na
var int nLongs = na, var int nShorts = na, nLongs := nz(nLongs[1]), nShorts := nz(nShorts[1])

//STRATEGY ==========================================================================================================================================================================================================================================================================================================

L_basic_condt = L_adx and L_rsi and L_mfi and volumegood and L_jma and L_macd and L_s_ma and L_sar and L_delta
S_basic_condt = S_adx and S_rsi and S_mfi and volumegood and S_jma and S_macd and S_s_ma and S_sar and S_delta
L_first_condt = L_basic_condt or L_scalp_condt and L_adx 
S_first_condt = S_basic_condt or S_scalp_condt and S_adx 
longCond := L_first_condt
shortCond := S_first_condt
CondIni_long := longCond[1] ? 1 : shortCond[1] ? -1 : nz(CondIni_long[1])
CondIni_short := longCond[1] ? 1 : shortCond[1] ? -1 : nz(CondIni_short[1])
longCondition = (longCond[1] and nz(CondIni_long[1]) == -1)
shortCondition = (shortCond[1] and nz(CondIni_short[1]) == 1)

// Price position----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

var int last_long_sl = na, var int last_short_sl = na
last_open_longCondition := longCondition ? close[1] : nz(last_open_longCondition[1]) 
last_open_shortCondition := shortCondition ? close[1] : nz(last_open_shortCondition[1])
last_longCondition := longCondition ? time : nz(last_longCondition[1])
last_shortCondition := shortCondition ? time : nz(last_shortCondition[1])
in_longCondition = last_longCondition > last_shortCondition
in_shortCondition = last_shortCondition > last_longCondition

if longCondition
    nLongs := nLongs + 1
    nShorts := na
    
if shortCondition
    nLongs := na
    nShorts := nShorts + 1
    
//TP_1 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

tp = input(1.7, "% Take profit 1", type = input.float, step = 0.1) 
var bool long_tp = na, var bool short_tp = na
var int last_long_tp = na, var int last_short_tp = na
var bool Final_Long_tp  = na, var bool Final_Short_tp = na, Final_Long_tp := nz(Final_Long_tp[1]), Final_Short_tp := nz(Final_Short_tp[1])
long_tp := (is_Long and high > (last_open_longCondition*(1+(tp/100))) and  in_longCondition)
short_tp := (is_Short and low < (last_open_shortCondition*(1-(tp/100))) and  in_shortCondition)
last_long_tp := long_tp ? time : nz(last_long_tp[1])
last_short_tp := short_tp ? time : nz(last_short_tp[1])
Final_Long_tp := (long_tp and last_longCondition > nz(last_long_tp[1]) and last_longCondition > nz(last_long_sl[1]))
Final_Short_tp := (short_tp and last_shortCondition > nz(last_short_tp[1]) and last_shortCondition > nz(last_short_sl[1]))

//TP_2 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Act_tp2 = input(true, "TP-2")
tp2 = input(2.3, "% Take profit 2", type = input.float, step = 0.1) 
var bool long_tp2 = na, var bool short_tp2 = na
var int last_long_tp2   = na, var int last_short_tp2 = na
var bool Final_Long_tp2 = na, var bool Final_Short_tp2 = na, Final_Long_tp2 := nz(Final_Long_tp2[1]), Final_Short_tp2 := nz(Final_Short_tp2[1])
long_tp2 := (Act_tp2 and is_Long and high > (last_open_longCondition*(1+(tp2/100))) and  in_longCondition)
short_tp2 := (Act_tp2 and is_Short and low < (last_open_shortCondition*(1-(tp2/100))) and  in_shortCondition)
last_long_tp2 := long_tp2 ? time : nz(last_long_tp2[1])
last_short_tp2 := short_tp2 ? time : nz(last_short_tp2[1])
Final_Long_tp2 := (long_tp2 and last_longCondition > nz(last_long_tp2[1]) and last_longCondition > nz(last_long_sl[1]))
Final_Short_tp2 := (short_tp2 and last_shortCondition > nz(last_short_tp2[1]) and last_shortCondition > nz(last_short_sl[1]))

//TP_3 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Act_tp3 = input(true, "TP-3")
tp3 = input(3.4, " % Take profit 3", type    = input.float, step = 0.1) 
var bool long_tp3 = na, var bool short_tp3 = na
var int last_long_tp3 = na, var int last_short_tp3 = na
var bool Final_Long_tp3 = na, var bool Final_Short_tp3 = na, Final_Long_tp3 := nz(Final_Long_tp3[1]), Final_Short_tp3 := nz(Final_Short_tp3[1])
long_tp3 := (Act_tp3 and is_Long and high > (last_open_longCondition*(1+(tp3/100))) and  in_longCondition)
short_tp3 := (Act_tp3 and is_Short and low < (last_open_shortCondition*(1-(tp3/100))) and  in_shortCondition)
last_long_tp3 := long_tp3 ? time : nz(last_long_tp3[1])
last_short_tp3 := short_tp3 ? time : nz(last_short_tp3[1])
Final_Long_tp3 := (long_tp3 and last_longCondition > nz(last_long_tp3[1]) and last_longCondition > nz(last_long_sl[1]))
Final_Short_tp3 := (short_tp3 and last_shortCondition > nz(last_short_tp3[1]) and last_shortCondition > nz(last_short_sl[1]))
Final_longCondition := is_Long and longCondition
Final_shortCondition := is_Short and shortCondition

//RE-ENTRY ON TP-HIT-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

var float sum_long = 0.0, var float sum_short = 0.0
var float Position_Price = 0.0

if Final_Long_tp3 
    CondIni_long := -1
    sum_long := 0.0
    nLongs := na
if Final_Short_tp3 
    CondIni_short := 1
    sum_short := 0.0
    nShorts := na
   
//BAR COLORS =======================================================================================================================================================================================================================================================================================================

bar_col = L_mfi ? color.green : S_mfi ? color.red :  L_scalp_condt ? color.lime : S_scalp_condt ? color.maroon : color.orange
barcolor(color = bar_col)

//PLOTSPAHES =======================================================================================================================================================================================================================================================================================================

plotshape(Final_longCondition, title="Long", style=shape.triangleup, location=location.belowbar, color=color.blue,   size=size.small)
plotshape(Final_shortCondition, title="Short", style=shape.triangledown, location=location.abovebar, color=color.red,   size=size.small)

plotshape(Final_Long_tp and not Final_Long_tp2, title = "TP1", style = shape.triangledown, location = location.abovebar, text="TP1", textcolor=color.red,  color = color.red, size = size.tiny) 
plotshape(Final_Short_tp and not Final_Short_tp2, title = "TP1", style = shape.triangleup, location = location.belowbar, text="TP1", textcolor=color.green,color = color.green, size = size.tiny) 

plotshape(Final_Long_tp2 and not Final_Long_tp and not Final_Long_tp3, title = "TP2", style = shape.triangledown, location = location.abovebar, text="TP2", textcolor=color.red,  color = color.red, size = size.tiny) 
plotshape(Final_Short_tp2 and not Final_Short_tp and not Final_Short_tp3, title = "TP2", style = shape.triangleup, location = location.belowbar, text="TP2", textcolor=color.green,color = color.green, size = size.tiny) 

plotshape(Final_Long_tp3 and not Final_Long_tp2, title = "TP3", style = shape.triangledown, location = location.abovebar, text="TP3", textcolor=color.red,  color = color.red, size = size.tiny) 
plotshape(Final_Short_tp3 and not Final_Short_tp2, title = "TP3", style = shape.triangleup, location = location.belowbar, text="TP3", textcolor=color.green,color = color.green, size = size.tiny) 

plotshape(Final_Long_tp and Final_Long_tp2, title  = " 💵 ", style = shape.triangledown, location = location.abovebar, text=" 💵 ", color = color.red, size = size.small) 
plotshape(Final_Short_tp and Final_Short_tp2, title = " 💵 ", style = shape.triangledown, location = location.belowbar, text=" 💵 ", color = color.green, size = size.small) 

plotshape(Final_Long_tp2 and Final_Long_tp3, title = " 💰 ", style = shape.triangledown, location = location.abovebar, text=" 💰 ", color = color.red, size = size.small) 
plotshape(Final_Short_tp2 and Final_Short_tp3, title = " 💰 ", style = shape.triangledown, location = location.belowbar, text=" 💰 ", color = color.green, size = size.small) 
 

//BACKTESTING--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if L_first_condt and ACT_BT
    strategy.entry( "L", strategy.long)

if S_first_condt and ACT_BT
    strategy.entry( "S", strategy.short)


per(pcnt) =>
    strategy.position_size != 0 ? round(pcnt / 100 * strategy.position_avg_price / syminfo.mintick) : float(na)
stoploss = input(title="stop loss", defval=9, minval=0.01)
los = per(stoploss)

q1 = input(title="% TP1 Q ", defval=33, minval=1)
q2 = input(title="% TP2 Q",  defval=66, minval=1)
q3 = input(title="% TP3 Q",  defval=100, minval=1)

strategy.exit("TP1", qty_percent = q1, profit = per(tp), loss = los)
strategy.exit("TP2", qty_percent = q2, profit = per(tp2), loss = los)
strategy.exit("TP3", qty_percent = q3, profit = per(tp3), loss = los)
